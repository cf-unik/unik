package osv

import (
	"github.com/emc-advanced-dev/pkg/errors"
	"github.com/emc-advanced-dev/unik/pkg/compilers"
	"github.com/emc-advanced-dev/unik/pkg/types"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
)

type OSvNodeCompiler struct {
	ImageFinisher ImageFinisher
}

func (r *OSvNodeCompiler) CompileRawImage(params types.CompileImageParams) (*types.RawImage, error) {

	// Prepare meta/run.yaml for node runtime.
	if err := addRuntimeStanzaToMetaRun(params.SourcesDir, "node"); err != nil {
		return nil, err
	}

	// Create meta/package.yaml if not exist.
	if err := assureMetaPackage(params.SourcesDir); err != nil {
		return nil, err
	}

	// Compose image inside Docker container.
	imagePath, err := CreateImageDynamic(params, r.ImageFinisher.UseEc2())
	if err != nil {
		return nil, err
	}

	// And finalize it.
	convertParams := FinishParams{
		CompileParams:    params,
		CapstanImagePath: imagePath,
	}
	return r.ImageFinisher.FinishImage(convertParams)
}

func (r *OSvNodeCompiler) Usage() *compilers.CompilerUsage {
	return &compilers.CompilerUsage{
		GeneralDescription: `
Language "nodejs" allows you to run your NodeJS 4.4.5 application.
Please provide meta/run.yaml file where you describe your project
structure. See below for more details.
`,
		PrepareApplication: "Install all libraries using `npm install`.",
		ConfigurationFiles: map[string]string{
			"/meta/run.yaml": `
config_set:
   conf1:
      main: <relative-path-to-your-entrypoint>   
config_set_default: conf1
`,
			"/manifest.yaml": `
image_size: "10GB"  # logical image size
`,
		},
	}
}

func addRuntimeStanzaToMetaRun(sourcesDir, runtime string) error {
	filepath := filepath.Join(sourcesDir, "meta", "run.yaml")

	// - Read.
	data, err := ioutil.ReadFile(filepath)
	if err != nil {
		return errors.New("failed to read meta/run.yaml file", err)
	}
	// - Modify.
	content := string(data)
	re := regexp.MustCompile("(?m)[\r\n]+^.*runtime:.*$")
	content = re.ReplaceAllString(content, "")
	content = "runtime: " + runtime + "\n\n" + content

	// - Write.
	if err = ioutil.WriteFile(filepath, []byte(content), 0644); err != nil {
		return errors.New("failed to write to meta/run.yaml", err)
	}

	return nil
}

func assureMetaPackage(sourcesDir string) error {
	filepath := filepath.Join(sourcesDir, "meta", "package.yaml")

	// Do nothing if meta/package.yaml already exist.
	if _, err := os.Stat(filepath); os.IsNotExist(err) {
		// Write.
		content := `
name: package.unik
title: Capstan package auto-generated by UniK
author: UniK
`
		if err := ioutil.WriteFile(filepath, []byte(content), 0644); err != nil {
			return errors.New("failed to write to meta/package.yaml", err)
		}
	}

	return nil
}
